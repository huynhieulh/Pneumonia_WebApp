# -*- coding: utf-8 -*-
"""Resnet_keras.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fstl0Yr7p0-jEWt1EsCrt3JKWDNIfCNC
"""

!pip3 install tensorflow==1.15.0

!pip3 install keras==2.2.4

import keras
import matplotlib.pyplot as plt
from keras.models import Sequential
from keras.layers import Dense, Conv2D, Dropout, Flatten, MaxPooling2D
import numpy as np
import cv2
import os

#Install kaggle
!pip install -q kaggle
print('Installed.')

#Download dataset
os.environ['KAGGLE_USERNAME'] = "lehuynhhieu"
os.environ['KAGGLE_KEY'] = "0be671e980bd840be15accec8e602627"
#!kaggle datasets list
!kaggle datasets download -d paultimothymooney/chest-xray-pneumonia

#Unzip dataset
!unzip -q chest-xray-pneumonia.zip -d chest-xray-pneumonia
print('Unzip done!')

#Size image
IMGS = 256
#Directory paths:
main = '/content/chest-xray-pneumonia/chest_xray/'
categ = ['test', 'train', 'val']
classes = ['NORMAL','PNEUMONIA']
images = []
labels = []
for i in categ:
    sub_path = os.path.join(main, i)
    for j  in classes:
        path = os.path.join(sub_path, j) 
        temp = os.listdir(path)
        for x in temp:
            addr = os.path.join(path, x)
            img_arr = cv2.imread(addr)
            img_arr = cv2.resize(img_arr, (IMGS, IMGS))
            images.append(img_arr)
            if j == 'PNEUMONIA':
                l = 1
            else:
                l = 0
            labels.append(l)
print('Done.')

images = np.array(images)
labels = np.array(labels)
print(images.shape, labels.shape)

#Split train / valid
from sklearn.model_selection import train_test_split as tts


x_train, x_test, y_train, y_test = tts(images, labels, random_state = 42, test_size = .20)
x_train.shape, y_train.shape, x_test.shape, y_test.shape

import seaborn as sns

#The graph shows the number of datasets
fig = plt.figure(figsize = (12, 4))
plt.grid(True)
plt.axis(False)

fig.add_subplot(1, 4, 1)
sns.countplot(labels, palette = 'summer')
plt.xlabel('All')

fig.add_subplot(1, 4, 2)
sns.countplot(y_train, palette = 'summer')
plt.xlabel('Train')

fig.add_subplot(1, 4, 3)
sns.countplot(y_test, palette = 'summer')
plt.xlabel('Test')

##fig.add_subplot(1, 4, 4)
#sns.countplot(y_valid, palette = 'summer')
#plt.xlabel('Valid')

plt.show()

#History
def plot_history(history, desc = ''):
    
    fig = plt.figure(figsize = (18 , 6))
    
    if desc:
        plt.title('{}'.format(desc), fontsize = 16, y = -0.1)

    subplot = (1, 2, 1)
    fig.add_subplot(*subplot)
    plt.plot(history.history['loss'])
    plt.plot(history.history['val_loss'])
    plt.title('model loss')
    plt.xlabel('epoch')
    plt.ylabel('loss')
    plt.legend(['train loss', 'valid loss'])
    plt.grid(True)
    plt.plot()
    
    subplot = (1, 2, 2)
    fig.add_subplot(*subplot)
    plt.plot(history.history['acc'])
    plt.plot(history.history['val_acc'])
    plt.title('model accuracy')
    plt.xlabel('epoch')
    plt.ylabel('accuracy')
    plt.legend(['train acc', 'valid acc'])
    plt.grid(True)
    plt.plot()

x_train = x_train.reshape(-1, IMGS, IMGS, 3)
#x_valid = x_valid.reshape(-1, IMGS, IMGS, 3)
x_test = x_test.reshape(-1, IMGS, IMGS, 3)
print('Done.')
print(x_train.shape, x_test.shape)

model_9 = Sequential()

# 1st Convolution block
model_9.add(Conv2D(16, (3, 3), strides=1, padding='same', activation='relu',
                        input_shape=(256, 256, 3)))
model_9.add(MaxPooling2D((2, 2), strides=2, padding='same'))

# 2nd Convolution block
model_9.add(Conv2D(32, (1, 1), strides=1, padding='same', activation='relu'))
model_9.add(Conv2D(32, (3, 3), strides=1, padding='same', activation='relu'))
model_9.add(Conv2D(32, (1, 1), strides=1, padding='same', activation='relu'))
model_9.add(MaxPooling2D((2, 2), strides=2, padding='same'))

# 3rd Convolution block
model_9.add(Conv2D(64, (1, 1), strides=1, padding='same', activation='relu'))
model_9.add(Conv2D(64, (3, 3), strides=1, padding='same', activation='relu'))
model_9.add(Conv2D(64, (1, 1), strides=1, padding='same', activation='relu'))
model_9.add(MaxPooling2D((2, 2), strides=2))

# 4th Convolution block
model_9.add(Conv2D(96, (1, 1), strides=1, padding='same', activation='relu'))
model_9.add(Conv2D(96, (3, 3), strides=1, padding='same', activation='relu'))
model_9.add(Conv2D(96, (1, 1), strides=1, padding='same', activation='relu'))
model_9.add(MaxPooling2D((2, 2), strides=2))

# 5th Convolution block
model_9.add(Conv2D(128, (1, 1), strides=1, padding='same', activation='relu'))
model_9.add(Conv2D(128, (3, 3), strides=1, padding='same', activation='relu'))
model_9.add(Conv2D(128, (1, 1), strides=1, padding='same', activation='relu'))
model_9.add(MaxPooling2D((2, 2), strides=2))

# Flattened the layer
model_9.add(Flatten())

# Fully connected layers
model_9.add(Dense(64, activation='relu'))
model_9.add(Dropout(0.2))
model_9.add(Dense(1, activation='sigmoid'))

model_9.summary()

model_9.compile(optimizer= keras.optimizers.Adam(lr=0.001), loss='binary_crossentropy', metrics=['accuracy'])
history = model_9.fit(x_train, y_train, epochs = 10, batch_size = 32, validation_data=(x_test, y_test))

plot_history(history)

model_9.evaluate(x_test, y_test)

y_pred = model_9.predict(x_test)

y_pred = np.round(y_pred)
y_pred = y_pred.reshape(-1,)
y_test = y_test.astype('float')
y_test.shape

def plot_confusion_matrix(cm, class_names):
    """
    Returns a matplotlib figure containing the plotted confusion matrix.
    
    Args:
       cm (array, shape = [n, n]): a confusion matrix of integer classes
       class_names (array, shape = [n]): String names of the integer classes
    """
    
    figure = plt.figure(figsize=(8, 8))
    plt.imshow(cm, interpolation='nearest', cmap=plt.cm.Blues)
    plt.title("Confusion matrix")
    plt.colorbar()
    tick_marks = np.arange(len(class_names))
    plt.xticks(tick_marks, class_names, rotation=45)
    plt.yticks(tick_marks, class_names)
    
    # Normalize the confusion matrix.
    cm = np.around(cm.astype('float') / cm.sum(axis=1)[:, np.newaxis], decimals=2)
    
    # Use white text if squares are dark; otherwise black.
    threshold = cm.max() / 2.
    
    for i in range (cm.shape[0]):
      for j in range (cm.shape[1]):
        color = "white" if cm[i, j] > threshold else "black"
        plt.text(j, i, cm[i, j], horizontalalignment="center", color=color)
        
    plt.tight_layout()
    plt.ylabel('True label')
    plt.xlabel('Predicted label')
    return figure

from sklearn.metrics import classification_report, confusion_matrix
print(classification_report(np.round(y_pred),y_test))

plot_confusion_matrix(confusion_matrix(y_test, y_pred),['Normal', 'Pneumonia'])

import seaborn as sns
sns.heatmap(confusion_matrix(y_test, y_pred), annot=True)